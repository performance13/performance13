<!-- Что возвращает логический оператор ||? -->

False только если всё false, иначе первое true

ИЛИ «||» находит первое истинное значение
|| запинается на true или последний операнд
alert( true || true ); // true
alert( false || true ); // true
alert( true || false ); // true
alert( false || false ); // false
Как мы можем наблюдать, результат операций всегда равен true, за исключением случая, когда оба аргумента false.
Если значение не логического типа, то оно к нему приводится в целях вычислений.
Например, число 1 будет true, а 0 – false:
Оператор || выполняет следующие действия:
*Вычисляет операнды слева направо.
*Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда.
\*Если все операнды являются ложными (false), возвращает последний из них.

Значение возвращается в исходном виде, без преобразования.

Другими словами, цепочка ИЛИ "||" возвращает первое истинное значение или последнее, если такое значение не найдено.

<!-- Где будет видна переменная, объявленная глобально? -->

Везде, как глобально, так и внутри блоков.

<!-- Какой метод объекта Math округлит указанное число до целого в меньшую сторону, не зависимо от его значения?  -->

Math.floor()

Math.floor() - округление вниз. Округляет аргумент до ближайшего меньшего целого.
Math.ceil() - округление вверх. Округляет аргумент до ближайшего большего целого.
Math.round() - если дробная часть числа больше либо равна 0,5, аргумент будет округлён до ближайшего большего целого; если дробная часть числа меньше 0,5, аргумент будет округлён до ближайшего меньшего целого.

<!-- Укажите верные ложные значения в логическом преобразовании.  -->

false, 0, NaN, null, undefined, ""

<!-- Что хранит свойство lenght? -->

Общая длина строки, включая знаки и символы.

Свойство String.length представляет длину строки.
Свойство Array.length - свойство length объекта, который является экземпляром типа Array, устанавливает или возвращает число элементов этого массива. Значение данного свойства 32-битное безнаковое целое число, которое всегда численно больше чем самый наибольший индекс в массиве.

<!-- Что делает метод Math.random() * (10 - 1) + 1)? -->

Выводит случайное число от 1 до 10

<!-- console.log(Math.random() * (10-1)+1); -->

<!-- Какой метод объекта Math округлит указанное число до целого по общепринятому правилу округления 0.5? -->

Math.round()

<!-- Какой результат возвращает оператор "%"? -->

остаток от деления

Бинарный оператор. Возвращает целочисленный остаток от деления двух операндов.

<!-- Что возвращает логический оператор "!"? -->

Противоположное значение

<!-- С какой цифры начинается отсчет индексов в строке?  -->

0

<!-- Какая функция приводит значение к строке?  -->

String(val)

<!-- Что делает метод Math.pow(2, 1) -->

Возводит значение первого параметра в степень второго параметра.

Метод Math.pow() Возводит значение первого параметра в степень второго параметра. Math.pow(base, exponent)
Math.pow(7, 2); // 49

<!-- Что возвращает логический оператор &&? -->

Последнее true, если всё true, иначе false

И запинается на false или последний операнд. К false приводится 0, NaN, null, undefined, пустая строка "" или '', false
При использовании булевых величин в качестве операндов, оператор && возвращает true , если оба операнда true ; в противном случае возвращает false .

<!-- Почему в Js 0.1 + 0.2 не равно 0.3? -->

Js не может точно представить 0.1 и большую часть других дробей, которые в двоичной системе являются бесконечными.

При сложении не целых чисел в JavaScript, и других языках программирования, есть особенность. Если кратко, то 0.1 + 0.2 не равно 0.3, результат сложения больше чем 0.3. Все от того что машина считает в двоичной системе.
Число 0.1 в двоичной системе счисления - это бесконечная дробь, так как единица на десять в двоичной системе не делится. Также бесконечной дробью является 0.2. Двоичное значение бесконечных дробей хранится только до определенного знака, поэтому возникает неточность. При сложении 0.1 и 0.2, две неточности складываются, получается незначительная, но всё же ошибка в вычислениях.

<!-- В чем разница методов Number.parseInt() и Number.parseFloat()? -->

parseFloat() парсит дробное число, а parseInt() нет

JavaScript предоставляет два метода преобразования нечисловых примитивов в цифры: parseInt() и parseFloat(). parseInt() преобразует значение в целое число. parseFloat() преобразует значение в число с плавающей запятой.

<!-- Какая функция приводит значение к числу?
 -->

Number(val)

Number является объектом-обёрткой, позволяющей работать с числовыми значениями. Number создаётся через конструктор Number().

<!-- Что вернет проверка числа на число с помощью метода Number.isNaN(val)? -->

false

! 6 значений которые приводятся к false

let=isNaN;
console.log(Number.isNaN()); //false

<!-- Что возвращает оператор "**"? -->

Возводит значение первого указанного параметра в степень, соответствующую значению второго параметра.

<!-- 2 ** 3 вернёт 8 -->

<!-- Какой метод объекта Math округлит указанное число до целого в большую сторону, не зависимо от его значения?  -->

Math.ceil()

<!-- Какая функция приводит значение к булеану? -->

Boolean(val)

Boolean является объектом-обёрткой над примитивом логического типа.

<!-- Где будет видна переменная, объявленная локально? -->

Внутри блока, в котором объявлена и его дочерних блоках.

В JavaScript до ES6 блочных областей видимости не было. Т.е. любая переменная созданная с помощью ключевого слова var внутри блока будет видима и за его пределами.

В ES6 были введены ключевые слова let и const. Они предназначены для создания переменных и констант, видимость которых будет ограничено блоком в котором они объявлены. Блочная область видимости в JavaScript определяется посредством фигурных скобок.

Глобальная область видимости используется по умолчанию. Все и вся имеют доступ к переменным объявленным в ней. Переменные объявленные в глобальной области видимости уязвимы, так как их может изменить любой участок кода.

Глубина вложенности областей видимости не ограничена, и все они буду работать по одному принципу - область видимости имеет доступ ко всем переменным объявленным выше по иерархии вложенности, но не может получить доступ к переменным объявленным во вложенных областях видимости.

видимость изнутри во вне
